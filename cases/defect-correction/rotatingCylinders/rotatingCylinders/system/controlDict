/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  v2312                                 |
|   \\  /    A nd           | Website:  www.openfoam.com                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    location    "system";
    object      controlDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

application     simpleFoam; 

startFrom       startTime;

startTime       0;

stopAt          endTime;

endTime         5000;

deltaT          1;

writeControl    timeStep;

writeInterval   10;

purgeWrite      3;

writeFormat     ascii;

writePrecision  6;

writeCompression off;

timeFormat      general;

timePrecision   6;

runTimeModifiable true;

functions
{
    transform1
    {
        type            fieldCoordinateSystemTransform;
        libs            (fieldFunctionObjects);
        writeControl    writeTime;

        fields          (U);
        coordinateSystem
        {
            origin      (0 0 0);
            rotation    none;
        }
    }

    sample1
    {
        type            sets;
        libs            (sampling);
        writeControl    writeTime;
        fields          (U p);
        interpolationScheme cellPoint;
        setFormat       raw;

        sets
        (
            centreLine
            {
                type        uniform;
                axis        x;
                start       (1 0 0);
                end         (2 0 0);
                nPoints     20;
            }
        );
    }

   // calculateFieldErrors
   // {
   //     type coded;
   //     name calculateFieldErrors;
   //     libs ("libutilityFunctionObjects.so");
   //     writeControl writeTime;

   //     codeInclude
   //     #{
   //         #include "fvCFD.H"
   //     #};

   //     codeData
   //     #{
   //         const scalar Omega1 = 100.0;
   //         const scalar Omega2 = 0.0;
   //         const scalar R1 = 1.0;
   //         const scalar R2 = 2.0;

   //         const scalar mu = Omega2 / Omega1;
   //         const scalar A = Omega1 * (1.0 - R2 * R2 * mu / R1 / R1) / (1.0 - R2 * R2 / R1 / R1);
   //         const scalar B = R1 * R1 * Omega1 * (1.0 - mu) / (1.0 - R1 * R1 / R2 / R2);
   //         const scalar C = 0.5 * A * A * R1 * R1 + 2.0 * A * B * log(R1) - 0.5 * B * B / (R1 * R1);

   //         tmp<volScalarField> pExactPtr;
   //         tmp<volScalarField> pErrPtr;

   //         tmp<volVectorField> UExactPtr;
   //         tmp<volVectorField> UErrPtr;
   //     #};

   //     codeRead
   //     #{
   //         // Initialize exact fields
   //         pExactPtr.reset
   //         (
   //             new volScalarField
   //     	(
   //     	    IOobject
   //     	    (
   //     	        "pExact", 
   //     		mesh().time().timeName(), 
   //     		mesh(), 
   //     		IOobject::NO_READ, 
   //     		IOobject::AUTO_WRITE
   //     	    ), 
   //     	    mesh(), 
   //     	    dimensionedScalar("p", dimPressure, 0.0)
   //     	)
   //         );

   //         UExactPtr.reset
   //         (
   //             new volVectorField
   //     	(
   //     	    IOobject
   //     	    (
   //     	        "UExact", 
   //     		mesh().time().timeName(), 
   //     		mesh(), 
   //     		IOobject::NO_READ, 
   //     		IOobject::AUTO_WRITE
   //     	    ), 
   //     	    mesh(), 
   //     	    dimensionedVector("U", dimVelocity, vector::zero)
   //     	)
   //         );

   //         //volScalarField& pExact = pExactPtr.ref();
   //         //volVectorField& UExact = UExactPtr.ref();

   //         //forAll(pExact, cellI)
   //         //{
   //         //    const vector pos = mesh().C()[cellI];
   //         //    scalar r = mag(pos); // radial distance
   //         //    pExact[cellI] = 0.5 * A * A * r * r + 2.0 * A * B * log(r) - 0.5 * B * B / (r * r) - C;
   //         //    UExact[cellI] = vector(0, A * r + B / r, 0);
   //         //}
   //     #};

   //     codeExecute
   //     #{
   //         //const volScalarField& p = mesh().lookupObject<volScalarField>("p");
   //         //const volScalarField& pExact = pExactPtr.cref();
   //         //volScalarField& pErr = const_cast<volScalarField&>(pErrPtr.cref());

   //         //const volVectorField& U = mesh().lookupObject<volVectorField>("U");
   //         //const volVectorField& UExact = UExactPtr.cref();
   //         //volVectorField& UErr = const_cast<volScalarField&>(UErrPtr.cref());

   //         //pErr.internalField() = mag(p.internalField() - pExact.internalField());
   //         //UErr.internalField() = U.internalField() - UExact.internalField();
   //     #};

   //     codeWrite
   //     #{
   //         //if (mrunTime.write())
   //         //{
   //             pExactPtr->write();
   //             pErrPtr->write();

   //     	UExactPtr->write();
   //             UErrPtr->write();
   //         //}
   //     #};
   //}
}

//DebugSwitches 
//{
//    solutionControl 1;
//}


// ************************************************************************* //
